//  This file was adapted from the Mekanism project, obtained 19/8/22
//  https://github.com/mekanism/Mekanism/blob/351554253dd69cbda96dfd6f00b8747b51122235/build.gradle
//  Special thank you to pupnewfster (Sara) of the Mekanism Team
//
//  Changes involve:
//  replacing mod and sub-mod names, and using different mod dependencies and versions
//  Changelog scraping via teamcity powershell script
//	Setting up gradle with the ability to use mixins in all sourcesets [main,allomancy,feruchemy,hemalurgy,sandmastery,surgebinding]
//	Removed jar that contains all mods in one, as I couldn't make it play nicely with mixins.
//	That meant I didn't need the groovy-script MergeJars
//

import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import net.minecraftforge.gradle.common.util.RunConfig
import net.minecraftforge.gradle.userdev.tasks.RenameJarInPlace

buildscript {
	repositories {
		maven { url = 'https://repo.spongepowered.org/repository/maven-public' }
	}
	dependencies {
		classpath group: 'org.spongepowered', name: 'mixingradle', version: '0.7-SNAPSHOT'
	}
}

plugins {
	id "com.matthewprenger.cursegradle" version '1.4.0'
	id 'java'
	id 'eclipse'
	id 'idea'
	id 'maven-publish'
	id 'net.minecraftforge.gradle' version '5.1.+'
	id 'org.parchmentmc.librarian.forgegradle' version '1.+'
	id 'org.spongepowered.mixin' version '0.7.+'
}


tasks.named('wrapper', Wrapper).configure {
	//Define wrapper values here so as to not have to always do so when updating gradlew.properties
	gradleVersion = '7.5.1'
	distributionType = Wrapper.DistributionType.ALL
}

defaultTasks 'build'

idea {
	module {
		//Exclude specific directories from being managed
		for (String excludeDirName in ["run", "runGameTests", "out", "logs", "gradle"]) {
			excludeDirs.add(new File(projectDir, excludeDirName))
		}
	}
}

def build_number = System.env.BUILD_NUMBER ?: 1
def full_mod_version = mod_version + "." + build_number
def release_type = System.env.TC_RELEASE_TYPE ?: "alpha"

ext {
	secondaryModules = ['allomancy', 'feruchemy', 'hemalurgy', 'surgebinding', 'sandmastery']
	extraTypes = ['datagen', 'gameTest']
	jsonPatterns = ["**/*.json", "**/*.mcmeta"]
	//version properties here automatically update versions in all the mods.toml files
	//we want that because updating every time something changes is tedious
	versionProperties = [
			"version"          : full_mod_version,
			"mc_version"       : minecraft_version_range,
			"forge_version"    : forge_version_range,
			"loader_version"   : loader_version_range,
			"patchouli_version": patchouli_version_range,
			"jade_version"     : jade_version_range,
			"jei_version"      : jei_version_range,
			"curios_version"   : curios_version_range
	]
}

sourceSets {
	api {
		//API is code only and does not have resources.
		resources.srcDirs = []
	}
	main {
		resources {
			include '**/**'
			// copy everything else, but blender and bbmodel files.
			exclude '**/*.blend'
			exclude '**/*.bbmodel'
			//Add the generated main module resources
			srcDirs += ['src/datagen/generated/cosmere']
			//But exclude the cache of the generated data from what gets built
			exclude '.cache'
		}
		compileClasspath += api.output
		runtimeClasspath += api.output
	}
	test {
		//The test module has no resources
		resources.srcDirs = []
		//Add the api to the output, all other ones that need to will get added via setupExtraSourceSets
		compileClasspath += api.output
		runtimeClasspath += api.output
	}
}

//Add all extra source sets that the main sourceSet should have
setupExtraSourceSets(sourceSets.main)

configurations {
	//Make sure all our sub source set stuff extends the proper base methods so that
	// they can see all the dependencies we have in dependencies including forge
	extendConfigurations(implementation, apiImplementation, testImplementation)
	extendConfigurations(compileOnly, apiCompileOnly, testCompileOnly)
	extendConfigurations(runtimeOnly, apiRuntimeOnly)
}

//Create sourceSets and configurations for each of the additional modules in src/$name and adds a reference to
// the corresponding data gen's resource directory excluding the cache. It also adds the api and main cosmere
// module to the dependencies of the source set we are setting up, and sets up all extra source sets that are
// based on the primary added source set
for (def name : secondaryModules) {
	def sourceSet = sourceSets.create(name)
	sourceSet.resources {
		//Add the generated module resources
		srcDirs += ["src/datagen/generated/${name}"]
		//But exclude the cache of the generated data from what gets built
		exclude '.cache'
	}
	sourceSet.compileClasspath += sourceSets.api.output
	sourceSet.compileClasspath += sourceSets.main.output
	//Create all secondary sourceSets for this module
	setupExtraSourceSets(sourceSet)
}

//Setup the UPDATE_SOURCESET property in case we are doing any remappings
project.ext."UPDATE_SOURCESETS" = project.sourceSets.collect { it.name }.join(';')


def setupExtraSourceSets(SourceSet base)
{
	project.sourceSets.test.compileClasspath += base.output
	project.sourceSets.test.runtimeClasspath += base.output
	//Setup and extend configurations for alternate modules. First by making the implementation, compileOnly, runtimeOnly equivalents
	// for those modules extend the main ones
	def baseImplementation = project.configurations.maybeCreate(base.getTaskName(null, "implementation"))
	def baseCompileOnly = project.configurations.maybeCreate(base.getTaskName(null, "compileOnly"))
	def baseRuntimeOnly = project.configurations.maybeCreate(base.getTaskName(null, "runtimeOnly"))
	if (base != project.sourceSets.main) {
		// If this is a secondary module then make the base tasks extend the builtin ones
		baseImplementation.extendsFrom(project.configurations.getByName("implementation"))
		baseCompileOnly.extendsFrom(project.configurations.getByName("compileOnly"))
		baseRuntimeOnly.extendsFrom(project.configurations.getByName("runtimeOnly"))
	}
	//And then setup and have all the extra sourceSets have their configurations extend the ones for the base module so that they can
	// properly access the dependency
	for (def extraType : extraTypes) {
		//Setup a source set in extraType/$name
		def extraSourceSet = setupExtraSourceSet(base, extraType)
		//And then setup the configurations for it
		project.configurations.maybeCreate(extraSourceSet.getTaskName(null, "implementation")).extendsFrom(baseImplementation)
		project.configurations.maybeCreate(extraSourceSet.getTaskName(null, "compileOnly")).extendsFrom(baseCompileOnly)
		project.configurations.maybeCreate(extraSourceSet.getTaskName(null, "runtimeOnly")).extendsFrom(baseRuntimeOnly)
	}
}

SourceSet setupExtraSourceSet(SourceSet baseSourceSet, String extra)
{
	def name = baseSourceSet.getName()
	def extraSourceSet = sourceSets.create(baseSourceSet.getTaskName(extra, null))
	extraSourceSet.java.srcDirs = ["src/${extra}/${name}/java"]
	//Resources folder for if we have anything get created by our annotation processors or in the case of game tests, for any nbt presets
	extraSourceSet.resources.srcDirs = ["src/${extra}/${name}/resources"]
	extraSourceSet.compileClasspath += project.sourceSets.api.output
	extraSourceSet.compileClasspath += project.sourceSets.main.output
	if (baseSourceSet != project.sourceSets.main) {
		//If the base sourceSet is main it already is the extra source set and has a reference to the base one from before this if statement
		extraSourceSet.compileClasspath += getExtraSourceSet(project.sourceSets.main, extra).output
		extraSourceSet.compileClasspath += baseSourceSet.output
	}
	return extraSourceSet
}

static void extendConfigurations(Configuration base, Configuration... configurations)
{
	for (def configuration : configurations) {
		configuration.extendsFrom(base)
	}
}

SourceSet getExtraSourceSet(String base, String name)
{
	return getExtraSourceSet(project.sourceSets.getByName(base), name)
}

SourceSet getExtraSourceSet(SourceSet base, String name)
{
	return project.sourceSets.getByName(base.getTaskName(name, null))
}

//Update book build number
processResources {
	// Exclude datagenerator .cache directory
	exclude '.cache'

	filesMatching('data/cosmere/patchouli_books/guide/book.json') {
		filter {
			it.replaceAll("buildNumber", "${build_number}")
		}
	}
}

setupTasks(sourceSets.main)
for (def name : secondaryModules) {
	setupTasks(sourceSets.getByName(name))
}

def setupTasks(SourceSet sourceSet)
{
	def sourceSetName = sourceSet.name
	def compileTask = tasks.named(sourceSet.getCompileJavaTaskName(), JavaCompile)
	def replaceResourceTask = tasks.register(sourceSet.getTaskName("replace", "resources"), Copy, {
		setGroup("replace resources")
		outputs.upToDateWhen { false }
		def modsToml = copySpec {
			from(sourceSet.resources) {
				include "META-INF/mods.toml"
				expand versionProperties
			}
		}
		def packMcMeta = copySpec {
			from(sourceSet.resources) {
				include "pack.mcmeta"
				// I don't want to auto-replace pack format values since I don't want
				// to adopt the datagen core mod pack filter suppressor in mekanism
				//expand packProperties
			}
		}
		//Copy it into the build dir
		with(modsToml, packMcMeta)
		into "$buildDir/resources/${sourceSetName}/"
		//If IntelliJ's output dir exists, copy it there as well
		def intellijPath = sourceSet == project.sourceSets.main ? "production" : sourceSetName
		if (new File("$rootDir/out/${intellijPath}/resources/").exists()) {
			copy {
				with(modsToml, packMcMeta)
				into "$rootDir/out/${intellijPath}/resources/"
			}
		}
		//If Eclipse's output dir exists, copy it there as well
		if (new File("$rootDir/bin/${sourceSetName}/").exists()) {
			copy {
				with(modsToml, packMcMeta)
				into "$rootDir/bin/${sourceSetName}/"
			}
		}
	})
	//Set the various variables/settings for the different process resources tasks
	tasks.named(sourceSet.getProcessResourcesTaskName(), ProcessResources).configure {
		setGroup("process resources")
		duplicatesStrategy(DuplicatesStrategy.FAIL)
		exclude('META-INF/mods.toml', 'pack.mcmeta')
		from("${projectDir}") { include 'logo.png' }
		//Depend on the compile task so that we can map the computer methods as needed
		dependsOn(compileTask)
		finalizedBy(replaceResourceTask)
		doLast {
			fileTree(dir: getOutputs().getFiles().getAsPath(), includes: jsonPatterns).each {
				File file -> file.setText(JsonOutput.toJson(new JsonSlurper().parse(file)))
			}
		}
	}
	tasks.named(sourceSet.getCompileJavaTaskName(), JavaCompile).configure { setGroup("compile") }
	for (def extraType : extraTypes) {
		def extraSourceSet = getExtraSourceSet(sourceSet, extraType)
		tasks.named(extraSourceSet.getProcessResourcesTaskName(), ProcessResources).configure {
			setGroup("process resources")
			dependsOn(compileTask)
		}
		tasks.named(extraSourceSet.getCompileJavaTaskName(), JavaCompile).configure { setGroup("compile") }
	}
	//Make the various classes tasks depend on the corresponding replaceResources tasks in addition to the default processResources tasks they depend on
	tasks.named(sourceSet.getClassesTaskName()).configure { dependsOn(replaceResourceTask) }
}

archivesBaseName = "Cosmere"
group = 'leaf.cosmere'
version = "${minecraft_version}-${forge_version}-" + full_mod_version


java {
	toolchain.languageVersion = JavaLanguageVersion.of("${java_version}")
	withSourcesJar()
}

println "Java: ${System.getProperty 'java.version'}, JVM: ${System.getProperty 'java.vm.version'} (${System.getProperty 'java.vendor'}), Arch: ${System.getProperty 'os.arch'}"


minecraft {
	mappings channel: "${mappings_channel}", version: "${mappings_version}"

	accessTransformers.from(file('src/main/resources/META-INF/accesstransformer.cfg'),
			file('src/allomancy/resources/META-INF/accesstransformer.cfg'))

	runs {
		client {
			setupRunConfig(it, true)
			//The below if statements are to add args to your gradle.properties file in user home
			// (for me on windows, I created gradle.properties in %userprofile%\.gradle)
			// (DO NOT add them directly to the gradle.properties file for this project)
			if (project.hasProperty('mc_uuid')) {
				//Your uuid without any dashes in the middle
				args '--uuid', project.getProperty('mc_uuid')
			}
			if (project.hasProperty('mc_username')) {
				//Your username/display name, this is the name that shows up in chat
				// Note: This is not your email, even if you have a Mojang account
				args '--username', project.getProperty('mc_username')
			}
		}
		server { setupRunConfig(it, true) }
		gameTestServer { setupRunConfig(it, true, "runGameTests") }
		data {
			setupRunConfig(it, false)
			environment 'target', 'fmluserdevdata'

			args '--all', '--output', file('src/datagen/generated/'),
					'--mod', 'cosmere', '--existing', file('src/main/resources/')

			mods.named("cosmere").configure { source((SourceSet) sourceSets.datagenMain) }
			for (def name : secondaryModules) {
				def modName = "${name}"
				def extra = getExtraSourceSet(name, 'datagen')
				mods.named(modName).configure { source(extra) }
				args '--mod', modName, '--existing', file("src/${name}/resources/")
			}
		}
	}
}

def setupRunConfig(RunConfig runConfig, boolean supportsGameTests, String directory = "run")
{
	runConfig.workingDirectory(file(directory))
	//We aren't a multi-project config so we can disable the forced exit to allow gradle run tasks to stop gracefully
	runConfig.forceExit = false
	//This fixes Mixin application problems from other mods because their refMaps are SRG-based, but we're in a MCP env
	runConfig.property 'mixin.env.remapRefMap', 'true'
	runConfig.property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"
	if (supportsGameTests) {
		//Specify all our mods as domains to look for game tests
		runConfig.property 'forge.enabledGameTestNamespaces', 'cosmere,allomancy,feruchemy,hemalurgy,surgebinding,sandmastery'
	}

	if (project.hasProperty('forge_force_ansi')) {
		//Force ansi if declared as a gradle variable, as the auto detection doesn't detect IntelliJ properly
		// or eclipse's plugin that adds support for ansi escape in console
		runConfig.jvmArg('-Dterminal.ansi=' + project.getProperty('forge_force_ansi'))
	}

	runConfig.mods.register("cosmere").configure {
		sources((SourceSet[]) [sourceSets.main, sourceSets.api])
		if (supportsGameTests) source((SourceSet) sourceSets.gameTestMain)
	}
	for (def name : secondaryModules) {
		def base = sourceSets.getByName(name)
		def extra = supportsGameTests ? getExtraSourceSet(base, 'gameTest') : null
		runConfig.mods.register("${name}").configure {
			source(base)
			if (supportsGameTests) source(extra)
		}
	}
}


repositories {
	maven {
		name = 'GeckoLib'
		url 'https://dl.cloudsmith.io/public/geckolib3/geckolib/maven/'
	}
	maven {
		// location of the maven that hosts JEI files
		url "https://dvs1.progwml6.com/files/maven/"
	}
	maven {
		//used for patchouli
		url "https://maven.blamejared.com/"
	}
	maven {
		//curio
		url = "https://maven.theillusivec4.top/"
	}
	maven {
		//curios
		url 'https://modmaven.dev/'
	}
	maven {
		url "https://www.cursemaven.com"
		content {
			includeGroup "curse.maven"
		}
	}

	whenObjectAdded {
//ForgeGradle adds these in an afterEvaluate, so we need to catch them as they're added and exclude mod artifacts/groups
		if (it instanceof MavenArtifactRepository) {
			def url = it.url.toString()
			if (url == 'https://maven.minecraftforge.net/' || url == 'https://libraries.minecraft.net/' || url == 'https://repo.maven.apache.org/maven2/') {
				try {
					it.content {
						excludeGroup 'curse.maven'
						excludeGroup 'mezz.jei'
						excludeGroup 'top.theillusivec4.curios'
						excludeGroup 'vazkii.patchouli'
						excludeGroup 'software.bernie.geckolib'
					}
					println("Adding exclusions to ${url}")
				} catch (Exception ignored) {
					//oh well
				}
			}
		}
	}
}

dependencies {
	minecraft "net.minecraftforge:forge:${minecraft_version}-${forge_version}"
	annotationProcessor 'org.spongepowered:mixin:0.8.5:processor'
	apiAnnotationProcessor 'org.spongepowered:mixin:0.8.5:processor'
	allomancyAnnotationProcessor 'org.spongepowered:mixin:0.8.5:processor'
	feruchemyAnnotationProcessor 'org.spongepowered:mixin:0.8.5:processor'
	hemalurgyAnnotationProcessor 'org.spongepowered:mixin:0.8.5:processor'
	surgebindingAnnotationProcessor 'org.spongepowered:mixin:0.8.5:processor'
	sandmasteryAnnotationProcessor 'org.spongepowered:mixin:0.8.5:processor'

	compileOnly fg.deobf("mezz.jei:jei-${minecraft_version}-common-api:${jei_version}")
	compileOnly fg.deobf("mezz.jei:jei-${minecraft_version}-forge-api:${jei_version}")
	runtimeOnly fg.deobf("mezz.jei:jei-${minecraft_version}-forge:${jei_version}")

	compileOnly fg.deobf("curse.maven:jade-api-324717:${jade_api_id}")
	runtimeOnly fg.deobf("curse.maven:jade-324717:${jade_id}")

	runtimeOnly fg.deobf("top.theillusivec4.curios:curios-forge:${minecraft_version}-${curios_version}")
	compileOnly fg.deobf("top.theillusivec4.curios:curios-forge:${minecraft_version}-${curios_version}:api")

	compileOnly fg.deobf("vazkii.patchouli:Patchouli:${patchouli_version}:api")
	runtimeOnly fg.deobf("vazkii.patchouli:Patchouli:${patchouli_version}")

	implementation fg.deobf('software.bernie.geckolib:geckolib-forge-1.19:3.1.40')

}

mixin {
	// MixinGradle Settings
	add sourceSets.main, 'mixins.cosmere.refmap.json'
	add sourceSets.api, 'mixins.cosmere.api.refmap.json'
	add sourceSets.allomancy, 'mixins.cosmere.allomancy.refmap.json'
	add sourceSets.feruchemy, 'mixins.cosmere.feruchemy.refmap.json'
	add sourceSets.hemalurgy, 'mixins.cosmere.hemalurgy.refmap.json'
	add sourceSets.surgebinding, 'mixins.cosmere.surgebinding.refmap.json'
	add sourceSets.sandmastery, 'mixins.cosmere.sandmastery.refmap.json'

	config 'cosmere.mixins.json'
	//config 'cosmere.mixins.api.json'
	config 'allomancy.mixins.json'
	config 'feruchemy.mixins.json'
	config 'hemalurgy.mixins.json'
	config 'surgebinding.mixins.json'
}

def getManifestAttributes(String title)
{
	return [
			"Specification-Title"     : title,
			"Specification-Vendor"    : "Cosmere",
			"Specification-Version"   : "${project.ext.versionProperties["version"]}",
			"Implementation-Title"    : title,
			"Implementation-Version"  : "${project.ext.versionProperties["version"]}",
			"Implementation-Vendor"   : "Cosmere",
			"Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
			"Automatic-Module-Name"   : title.toLowerCase(Locale.ROOT),
			"MixinConfigs"            : "${title.toLowerCase(Locale.ROOT)}.mixins.json"
	]
}

tasks.named('jar', Jar).configure {
	duplicatesStrategy(DuplicatesStrategy.FAIL)
	from([sourceSets.api.output, sourceSets.main.output])
	manifest.attributes(getManifestAttributes("Cosmere"))
}

tasks.named('sourcesJar', Jar).configure {
	dependsOn(classes, apiClasses, allomancyClasses, feruchemyClasses, hemalurgyClasses, surgebindingClasses, sandmasteryClasses)
	duplicatesStrategy(DuplicatesStrategy.FAIL)
	//Note: Already contains main source set's sources by default
	from(sourceSets.api.allJava, sourceSets.allomancy.allJava, sourceSets.feruchemy.allJava, sourceSets.hemalurgy.allJava, sourceSets.surgebinding.allJava, sourceSets.sandmastery.allJava)
	manifest.attributes(getManifestAttributes("Cosmere"))
}

def secondaryJar(SourceSet sourceSet, String title)
{
	return tasks.register(sourceSet.getJarTaskName(), Jar, {
		duplicatesStrategy(DuplicatesStrategy.FAIL)
		archiveClassifier.set(sourceSet.name)
		from sourceSet.output
		if (!title.isEmpty()) {
			archiveFileName.set("Cosmere${title}-${project.version}.jar")
		}
		manifest.attributes(getManifestAttributes(title.isEmpty() ? "Cosmere" : title))
	})
}

def apiJar = secondaryJar(sourceSets.api, '')
def allomancyJar = secondaryJar(sourceSets.allomancy, 'Allomancy')
def feruchemyJar = secondaryJar(sourceSets.feruchemy, 'Feruchemy')
def hemalurgyJar = secondaryJar(sourceSets.hemalurgy, 'Hemalurgy')
def surgebindingJar = secondaryJar(sourceSets.surgebinding, 'Surgebinding')
def sandmasteryJar = secondaryJar(sourceSets.sandmastery, 'Sandmastery')

tasks.withType(JavaCompile).configureEach({
	options.encoding = 'UTF-8'
	options.compilerArgs.addAll(["-Xmaxerrs", "100000"])
})

artifacts {
	archives apiJar
	archives jar
	archives allomancyJar
	archives hemalurgyJar
	archives feruchemyJar
	archives surgebindingJar
	archives sandmasteryJar
	archives sourcesJar
}


createReobf(sourceSets.api)
for (def name : secondaryModules) {
	createReobf(sourceSets.getByName(name))
}

def createReobf(SourceSet sourceSet)
{
	def reobfTask = createReobf(sourceSet.getJarTaskName())
	reobfTask.configure { classpath.from(sourceSet.compileClasspath) }
	tasks.named(sourceSet.getJarTaskName()).configure(task -> task.finalizedBy(reobfTask))
	return reobfTask
}

def createReobf(String name)
{
	def reobfExtension = (NamedDomainObjectContainer<RenameJarInPlace>) extensions.getByName("reobf")
	//using maybeCreate instead of Register, as mixin environment gets confused.
	return reobfExtension.maybeCreate(name)
}

afterEvaluate {
	tasks.named('jar', Jar).configure { finalizedBy(tasks.named('reobfJar', RenameJarInPlace)) }
}

tasks.withType(RenameJarInPlace).configureEach {
	args.add('--stable')
}

tasks.withType(GenerateModuleMetadata) {
	//Disable Gradle 7 module metadata generation as it does not play nicely with FG
	enabled = false
}


clean {
	def filteredDelete = new HashSet<>()
	for (def toDelete : getDelete()) {
		for (def f : file(toDelete).listFiles()) {
			if (f.getName() == "generated") {
				for (def generated : file(f).listFiles()) {
					if (generated.getName() != "data" && generated.getName() != "META-INF") {
						filteredDelete.add(generated)
					}
				}
			} else if (f.getName() != "fg_cache") {
				filteredDelete.add(f)
			}
		}
	}
	setDelete(filteredDelete)
}

def resolvedChangelog = null

//closure to generate the changelog once, and only when needed by CurseGradle
def changeLogResolver = { ->
	String generatedChangelog;

	//autogenerated log via teamcity, which uses a generic powershell script to generate a changelog
	def autogeneratedChangelog = project.file("docs/changelog_Cosmere_${build_number}.txt")
	if (autogeneratedChangelog.exists()) {
		//Add any version specific changelog stuff
		def changelogText = autogeneratedChangelog.getText()
		generatedChangelog = "$changelogText"
	} else {
		generatedChangelog = "Unable to generate changelog :("
	}

	//add hand written log to put at the top
	def releaseNotesFile = project.file("docs/release_${build_number}.txt")
	if (releaseNotesFile.exists()) {
		//Add any version specific changelog stuff
		def releaseNotes = releaseNotesFile.getText()
		generatedChangelog = "$releaseNotes<br>-<br> $generatedChangelog"
	}


	generatedChangelog =
			"Cosmere and related sub module mods are considered to be in an alpha state! You have been warned :)" +
					"<br><br> $generatedChangelog"
	resolvedChangelog = generatedChangelog
	return generatedChangelog
}


if (System.getenv("CURSEFORGE_API_TOKEN") != null || project.hasProperty('curseforge_api_token')) {
	println "Enabling Curseforge config"
	tasks.named('curseforge').configure { dependsOn(jar, allomancyJar, feruchemyJar, hemalurgyJar, surgebindingJar, sandmasteryJar, apiJar) }
	curseforge {
		//https://authors.curseforge.com/account/api-tokens
		apiKey = System.getenv("CURSEFORGE_API_TOKEN") ?: project.findProperty("curseforge_api_token")

		//Main - Cosmere
		project {
			id = '475343'
			changelogType = "html"
			changelog = changeLogResolver
			releaseType = "${release_type}"
			mainArtifact(jar) {
				relations {
					optionalDependency "jade"
					optionalDependency "jei"
					optionalDependency "patchouli"
					optionalDependency "allomancy-cosmere"
					optionalDependency "feruchemy-cosmere"
					optionalDependency "hemalurgy-cosmere"
					optionalDependency "surgebinding"
					optionalDependency "sandmastery"
				}
			}
			addArtifact apiJar.get()
			addGameVersion "Java ${java_version}"
			addGameVersion "${minecraft_version}"
		}

		//Allomancy
		project {
			id = '678468'
			changelogType = "html"
			changelog = changeLogResolver
			releaseType = "${release_type}"
			mainArtifact(allomancyJar.get()) {
				relations {
					requiredDependency "cosmere"
					optionalDependency "patchouli"
					optionalDependency "hemalurgy-cosmere"
					optionalDependency "feruchemy-cosmere"
				}
			}
			addGameVersion "Java ${java_version}"
			addGameVersion "${minecraft_version}"
		}

		//Feruchemy
		project {
			id = '678466'
			changelogType = "html"
			changelog = changeLogResolver
			releaseType = "${release_type}"
			mainArtifact(feruchemyJar.get()) {
				relations {
					requiredDependency "cosmere"
					requiredDependency "curios"
					optionalDependency "patchouli"
					optionalDependency "hemalurgy-cosmere"
					optionalDependency "allomancy-cosmere"
				}
			}
			addGameVersion "Java ${java_version}"
			addGameVersion "${minecraft_version}"
		}

		//Hemalurgy
		project {
			id = '678469'
			changelogType = "html"
			changelog = changeLogResolver
			releaseType = "${release_type}"
			mainArtifact(hemalurgyJar.get()) {
				relations {
					requiredDependency "cosmere"
					requiredDependency "curios"
					optionalDependency "patchouli"
					requiredDependency "feruchemy-cosmere"
					requiredDependency "allomancy-cosmere"
					incompatible "hemalurgy"
				}
			}
			addGameVersion "Java ${java_version}"
			addGameVersion "${minecraft_version}"
		}

		//Surgebinding
		project {
			id = '624998'
			changelogType = "html"
			changelog = changeLogResolver
			releaseType = "${release_type}"
			mainArtifact(surgebindingJar.get()) {
				relations {
					requiredDependency "cosmere"
					optionalDependency "patchouli"
					optionalDependency "hemalurgy-cosmere"
					optionalDependency "allomancy-cosmere"
					optionalDependency "surgebinding"
				}
			}
			addGameVersion "Java ${java_version}"
			addGameVersion "${minecraft_version}"
		}

		//SandMastery
		project {
			id = '695387'
			changelogType = "html"
			changelog = changeLogResolver
			releaseType = "${release_type}"
			mainArtifact(sandmasteryJar.get()) {
				relations {
					requiredDependency "cosmere"
					requiredDependency "curios"
					optionalDependency "patchouli"
					optionalDependency "allomancy-cosmere"
					optionalDependency "feruchemy-cosmere"
					optionalDependency "hemalurgy-cosmere"
					optionalDependency "surgebinding"
				}
			}
			addGameVersion "Java ${java_version}"
			addGameVersion "${minecraft_version}"
		}
	}
}

